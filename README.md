# SRP DIP OCP
    - SRP 
        - 한 클래스는 하나의 책임만 가져야한다. > 관심사를 분리
    - DIP 
        - 추상화에 의존해야지 구체화에 의존하면 안된다 > 객체가 추상화에 의존을 해야함 . 
            구체적에 대한부분은 넣어주어야함
    - OCP
        - 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀 있다.

#BeanFactory
    - 스프링 컨테이너의 최상위 인터페이스 -> 빈을 관리하고 조회하는 역활

#ApplicationContext
    - beanFactory에 부가적인 기능 추가된 것 
    - 제공하는 부가기능
      - 환경변수 로컬, 개발, 운영등을 구분해서 처리(환경별로 어떤 것에 연결해야할지)
      - 어플리케이션 이벤트 (이벤트를 발행하고 구독하는 모델을 편리하게 지원)
      - 편리한 리소스 조회 (파일, 클래스패스, 외부 등 리소스를 편리하게 조회)

    ** 빈 관리기능 + 편리한 부가 기능 제공
    
    ** baenFactory, applicationContext는 스프링 컨테이너라함 **

#스프링 빈 설정 메타 정보 (beanDefinition <- 인터페이스)
    - 스프링 컨테이너는 설정 메타 정보를 기반으로 스프링 빈을 생성
    - 스프링컨테이너는 추상화에만 의존하도록 설계함 
    - 직접 생성해서 스프링 컨테이너에 등록할 수 있지만 직접 정의하거나 사용 할 일은 거의 없다.
    - 다양한 형태의 설정 정보를 메타정보로 추상화해서 사용함

#싱글톤
    - 스프링 없는 순수한 DI 컨테이너는 요청을 할 때마다 새로 생성한다.
    - 호출시 생성이 아닌 미리 만들어 둔 객체 인스턴스를 반환 
    
    - 문제점 
        - 클라이언트가 구체 클래스에 의존해야함 -> OCP위반됨
        - 테스트가 어려움
        - 유연성이 떨어짐 
        - 안티패턴으로 불림

* 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서 객체 인스턴스를 싱글톤으로 관리

#싱글톤 컨테이너
     - 싱글톤 컨테이너역할을 한다.
     - 싱글톤 패턴 단점 보완 
     - 요청이 올 때마다 객체를 생성하는게 아닌 이미 만들어진 객체를 공유해서 효율적으로 재사용 가능하다.

    ** 스프링은 싱글톤 방식으로 돌아간다 99.9%

    싱글톤 방식의 주의점 

    @Bean만 사용해도 스프링 빈으로 등록되지만 싱글톤 보장은 되지 않는다.
    @Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 빈이 없으면 생성해서 스프링빈을 등록하고 반환하는 코드가 동적으로 만들어짐 <- 싱글톤 보장이 가능해짐

        